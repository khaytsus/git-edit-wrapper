#!/bin/sh

# Editor wrapper script that edits the real file if the file is a symlink (some editors
# clobber symlinks), runs restorecon if selinux is enabled (some editors clobber contexts)
# and adds the edited file to a local git repo

# Warning:  If autogit=1 and no git repo is available in the current or parent
# structure we create a new one in the same path as the file.  If you want a
# more global repo, do git init on a higher path and files will be added to
# that repo instead.  Example:  cd $HOME ; git init

# Change the editor to your intended editor..  vi, emacs, joe, whatever
# and update pager if you want to view files you can't edit
editor=/usr/local/bin/me-bin
pager=/usr/bin/more

# If using selinux, make sure these are set to the correct path, otherwise
# you can set them blank to disable the selinux handling

restorecon=/sbin/restorecon
getenforce=/usr/sbin/getenforce

# If you want the script to automatically create a git repo if one does not
# already exist, set this to 1

autogit=1

# If you want the script to check in a file before editing if it already
# exists, set this to 1

precommit=1

# If you want the script to bail out on a binary file, set this to 1

nobinary=1

### No touchy below here

file=$1
originalfile=$file

if [ "$file" == "" ]; then
 $editor
 exit
fi

if [ -d "$file" ]; then
 echo "$file is a directory, aborting.."
 exit
fi

if [ "$nobinary" == "1" ]; then
  magic=`file -i "$file"`
  if grep -q binary <<< $magic
  then
    echo "Binary file found, aborting.."
    exit
  fi
fi

# Clean up our lock file and exit.  If we staged, but did not edit a file,
# remove it from the git cache
function cleanup
{
  rm "$filetest"
  if [ $precommitted == 1 ] && [ $edited == 0 ]; then
    git rm --cache "$filename"  >/dev/null 2>&1
  fi
  exit
}

function sigint
{
  echo -e "\nCaught interrupt, cleaning up"
  cleanup
}

trap sigint SIGINT

# Use readlink so we're editing the original file if a symlink as some editors
# clobber symlinks
file=`readlink -f "$file"`
dir=`dirname "$file"`
originaldir=`dirname "$originalfile"`
filename=`basename "$file"`
pwd=`pwd`
pwd=`readlink -f "$pwd"`
checksum="cleared-after-git"

# Flags to track the precommit so we only commit the pre-edited file when
# we've edited the file
precommitted=0
edited=0

# Create a lock file to test
filetest=$dir/.${filename}.lock

if [ -f "$filetest" ]; then
  echo "A lock file exists:  $filetest"
  exit
fi

if [ ! -d "$originaldir" ]; then
  echo "Directory $originaldir does not exist, aborting.."
  exit
fi

# Test if we can write to this location/file and create a lock file
touch "$filetest" >/dev/null 2>&1
rc=$?
if [ $rc != 0 ]; then
  if [ -f "$file" ]; then
    echo "Could not create $file (no permissions?)  Viewing instead"
    echo ""
    $pager "$file"
    exit
  else
    echo "Could not create $file (no permissions?)"
    exit
  fi
fi

# Function to let us commit a file before editing it if the file exists.
# If autogit = 1 and we need to, we'll create a git repo first
function precommit
{
# Need to be in the files path to test for a repo
  gitchecksum=0
  cd "$dir"

# If the file exists, see if we need to check it in before editing
  if [ -f "$file" ] && [ "$precommit" == "1" ]; then

# Test to see if we can and need to create a repo for precommit
    git rev-parse --git-dir >/dev/null 2>&1
    if [ "$autogit" == "1" ] && [ $? != 0 ]; then
      git init -q
    fi

# Test again to see if we created a repo
    git rev-parse --git-dir >/dev/null 2>&1
    if [ $? == 0 ]; then
      git add "$filename" >/dev/null 2>&1
      precommitted=1
      gitchecksum=1
      checksum=""
    fi
  fi

  if [ -f "$file" ] && [ "$gitchecksum" != 1 ]; then
# We can't use git to test, so we need a checksum to see if we edit the file
    checksum=`md5sum "$dir/$filename"`
  fi
}

# Ask user for commit note, otherwise default to something
function readcommit
{
  gitdir=`git rev-parse --git-dir`
  if [ $precommitted == 1 ]; then
    git commit -q -m "Pre-edit commit of file $file" >/dev/null 2>&1
  fi
  git add "$filename"
  echo -n "[$gitdir] message: "
  read commit
  if [ "$commit" == "" ]; then
    commit="Automatic edit script commit"
  fi
  git commit -q -m "$commit"
}

# Go back to our original path
cd "$pwd"

# Edit the file, but commit it first if we should
precommit
$editor "$file"

# If we didn't create a file, just exit
if [ ! -f "$file" ]; then
  cleanup
fi

# Exit if we didn't change the file at all, use git to determine if possible
if [ "$precommit" == "1" ] && [ "$checksum" == "" ]; then
  git rev-parse --git-dir >/dev/null 2>&1
  if [ $? == 0 ]; then
# TODO:  Find a better way to test this, ugh
    gittest=`git ls-files -m "$dir/$filename"`
    if [ "$gittest" == "" ]; then
      cleanup
    fi
  fi
else
  new_checksum=`md5sum "$dir/$filename"`
  if [ "$checksum" == "$new_checksum" ]; then
    cleanup
  fi
fi

# If we got here, we edited the file
edited=1

# If using selinux, restore our contexts
if [ -f "$getenforce" ]; then
  if $getenforce | grep -q 'Enforcing\|Permissive'
  then
   $restorecon "$file"
  fi
fi

# Now go back to the files full path to test for a git repo
cd "$dir"

# Check again to see if we have a repo
git rev-parse --git-dir >/dev/null 2>&1

# Is there is a git repo here?
if [ $? == 0 ]; then
  readcommit
else
  if [ "$autogit" == "1" ]; then
    echo "Creating new git repo in $dir"
    git init -q
    readcommit
  else
# If autogit=0, offer easy way to add file to a new repo
    echo "cd \"$dir\" && git init && git add \"$filename\" && git commit -m \"Adding $filename\" && cd $pwd"
  fi
fi

cleanup
