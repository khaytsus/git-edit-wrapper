#!/bin/sh

# Editor wrapper script that edits the real file if the file is a symlink (some editors
# clobber symlinks), runs restorecon if selinux is enabled (some editors clobber contexts)
# and adds the edited file to a local git repo

# Warning:  If autogit=1 and no git repo is available in the current or parent
# structure we create a new one in the same path as the file.  If you want a
# more global repo, do git init on a higher path and files will be added to
# that repo instead.  Example:  cd $HOME ; git init

# Change the editor to your intended editor..  vi, emacs, joe, whatever

editor=/usr/local/bin/me-bin

# If using selinux, make sure these are set to the correct path, otherwise
# you can set them blank to disable the selinux handling

restorecon=/sbin/restorecon
getenforce=/usr/sbin/getenforce

# If you want the script to automatically create a git repo if one does not
# already exist, set this to 1

autogit=1

# If you want the script to check in a file before editing if it already
# exists, set this to 1

precommit=1

### No touchy below here

file=$1
originalfile=$file

if [ "$file" == "" ]; then
 $editor
 exit
fi

if [ -d "$file" ]; then
 echo "$file is a directory, aborting.."
 exit
fi

# Use readlink so we're editing the original file if a symlink as some editors
# clobber symlinks

# If the file is in a git repo, check in the change
# If autogit is set to 1, we automatically create the repo
file=`readlink -f $file`
dir=`dirname $file`
filename=`basename $file`
pwd=`pwd`
pwd=`readlink -f $pwd`

# Create a lock file to test

filetest=$dir/.${filename}.lock

if [ -f $filetest ]; then
  echo "A lock file exists:  $filetest"
  exit
fi

# Test if we can write to this location/file and create a lock file
touch $filetest >/dev/null 2>&1
rc=$?
if [ $rc != 0 ]; then
  if [ -f $file ]; then
    echo "Could not create $file (no permissions?)  Using more instead"
    echo ""
    more $file
    exit
  else
    echo "Could not create $file (no permissions?)"
    exit
  fi
fi

# Function to let us commit a file before editing it if the file exists.
# If autogit = 1 and we need to, we'll create a git repo first
function precommit
{
# Need to be in the files path to test for a repo
  cd $dir

# If the file exists, see if we need to check it in before editing
  if [ -f "$file" ] && [ "$precommit" == "1" ]; then

# Get our original md5sum to test
    md5=`md5sum $originalfile`

# Test to see if we can and need to create a repo for precommit
    git rev-parse --git-dir >/dev/null 2>&1
    if [ "$autogit" == "1" ] && [ $? != 0 ]; then
      git init -q
    fi

# Test again to see if we created a repo
    git rev-parse --git-dir >/dev/null 2>&1
    if [ $? == 0 ]; then
      git add $filename >/dev/null 2>&1
      git commit -q -m "Pre-edit commit of file $file" >/dev/null 2>&1
    fi
  fi
}

# Ask user for commit note, otherwise default to something
function readcommit
{
  gitdir=`git rev-parse --git-dir`
  git add $filename
  echo -n "[$gitdir] message: "
  read commit
  if [ "$commit" == "" ]; then
    commit="Automatic edit script commit"
  fi
  git commit -q -m "$commit"
}

# Clean up our lock file and exit
function cleanup
{
   rm $filetest
   exit
}

# Go back to our original path
cd $pwd

# Edit the file, but commit it first if we should
precommit
$editor "$file"

# If we didn't create a file, just exit
if [ ! -f "$file" ]; then
  cleanup
fi

# Exit if we didn't change the file at all
new_md5=`md5sum $originalfile`
if [ "$md5" == "$new_md5" ]; then
  cleanup
fi

# If using selinux, restore our contexts
if [ -f "$getenforce" ]; then
  if $getenforce | grep -q 'Enforcing\|Permissive'
  then
   $restorecon "$file"
  fi
fi

# Now go back to the files full path to test for a git repo
cd $dir

# Check again to see if we have a repo
git rev-parse --git-dir >/dev/null 2>&1

# Is there is a git repo here?
if [ $? == 0 ]; then
  readcommit
else
  if [ "$autogit" == "1" ]; then
    echo "Creating new git repo in" `readlink -f $pwd`
    git init -q
    readcommit
  else
# If autogit=0, offer easy way to add file to a new repo
    echo "cd $dir && git init && git add $filename && git commit -m \"Adding $filename\" && cd $pwd"
  fi
fi

cleanup
