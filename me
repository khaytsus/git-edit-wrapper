#!/bin/sh

# Editor wrapper script that edits the real file if the file is a symlink (some editors
# clobber symlinks), runs restorecon if selinux is enabled (some editors clobber contexts)
# and adds the edited file to a local git repo

# Warning:  If autogit=1 and no git repo is available in the current or parent
# structure we create a new one in the same path as the file.  If you want a
# more global repo, do git init on a higher path and files will be added to
# that repo instead.  Example:  cd $HOME ; git init

# Change the editor to your intended editor..  vi, emacs, joe, whatever

editor=/usr/local/bin/me-bin

# If using selinux, make sure these are set to the correct path, otherwise
# you can set them blank to disable the selinux handling

restorecon=/sbin/restorecon
getenforce=/usr/sbin/getenforce

# If you want the script to automatically create a git repo if one does not
# already exist, set this to 1

autogit=1

# If you want the script to check in a file before editing if it already
# exists, set this to 1
precommit=1

### No touchy below here

file=$1
originalfile=$file

if [ "$file" == "" ]; then
 $editor
 exit
fi

if [ -d "$file" ]; then
 echo "$file is a directory, aborting.."
 exit
fi

# Test to see if we have write permissions, then clean up
filetest=`head /dev/urandom | md5sum | cut -f 1 -d " "`
filetest=${file}-${filetest}
touch $filetest >/dev/null 2>&1
rc=$?
if [ $rc != 0 ]; then
        echo "Could not create $file (no permissions?)  Using more instead"
	more $file
	exit
fi
rm $filetest

# Use readlink so we're editing the original file if a symlink as some editors
# clobber symlinks

# If the file is in a git repo, check in the change
# If autogit is set to 1, we automatically create the repo
file=`readlink -f $file`
dir=`dirname $file`
filename=`basename $file`
pwd=`pwd`
pwd=`readlink -f $pwd`

function precommit
{
  cd $dir

# If the file exists, see if we need to check it in before editing
  if [ -f "$file" ]; then
    md5=`md5sum $originalfile`

# Test to see if we need to create a repo for precommit
    git rev-parse --git-dir >/dev/null 2>&1
    if [ "$autogit" == "1" ] && [ $? != 0 ]; then
      git init -q
    fi

# Test again to see if we created one
    git rev-parse --git-dir >/dev/null 2>&1
# If precommit=1, check in the file before editing it
     if [ $? == 0 ] && [ $precommit == 1 ]; then
# Make sure the file isn't already there first
       git ls-files $filename --error-unmatch >/dev/null 2>&1
       if [ $? != 0 ]; then
         git add $filename >/dev/null 2>&1
         git commit -q -m "Pre-edit commit of file $file" >/dev/null 2>&1
       fi
     fi
  fi
}

# Go back to our original path for now
cd $pwd

# Edit the file
if [ -h "$file" ]; then
 if [ -d "$file" ]; then
  echo "$file is a directory, aborting.."
  exit
 else
  precommit
  $editor "$file"
 fi
else
 precommit
 $editor "$file"
fi

# If we didn't create a file, just exit
if [ ! -f "$file" ]; then
 exit
fi

# If using selinux, restore our contexts
if [ -f "$getenforce" ]; then
  if $getenforce | grep -q 'Enforcing\|Permissive'
  then
   $restorecon "$file"
  fi
fi

# Exit if we didn't change the file at all
new_md5=`md5sum $originalfile`
if [ "$md5" == "$new_md5" ]; then
  exit
fi

# Ask user for commit note, otherwise default to something
function readcommit
{
  gitdir=`git rev-parse --git-dir`
  git add $filename
  echo -n "[$gitdir] message: "
  read commit
  if [ "$commit" = "" ]; then
    commit="Automatic edit script commit"
  fi
  git commit -q -m "$commit"
}

# Now go back to the files full path to test for a git repo
cd $dir

# TODO:  This is goofy
git rev-parse --git-dir >/dev/null 2>&1
headrc=$?

# Is there is a git repo here?
if [ $headrc == 0 ]; then
  readcommit
else
  if [ "$autogit" = "1" ]; then
    echo "Creating new git repo in" `readlink -f $pwd`
    git init -q
    readcommit
  else
# If autogit=0, offer easy way to add file to a new repo
    echo "cd $dir && git init && git add $filename && git commit -m \"Adding $filename\" && cd $pwd"
  fi
fi
